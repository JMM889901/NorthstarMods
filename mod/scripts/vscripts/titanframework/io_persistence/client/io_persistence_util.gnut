untyped
globalize_all_functions



global struct frameworkHelperValuesStruct
{
    bool savingNewLoadout
}
global struct clientframeworkPersistentTitanLoadoutstruct
{
    array<string> filesToLoad
    string moddedLoadoutIndex
    table<string, frameworkPersistentTitanLoadout> loadouts//Indexed by filename
    array<frameworkPersistentTitanLoadout> loadoutsToSave //Should always be empty when not saving, used for race conditions (unless mutex already fixes that)
}


global clientframeworkPersistentTitanLoadoutstruct clientframeworkPersistentTitanLoadouts 
global frameworkHelperValuesStruct frameworkHelperValues
void function cl_titanFrameworkPersistenceInit()
{
    //RegisterSignal("FrameworkloadoutsReady")
    #if CLIENT
    AddServerToClientStringCommandCallback("FrameworkInformLoadoutResponse", FrameworkInformLoadoutResponse)
    
    #endif
    thread cl_titanFrameworkPersistenceInitThread()
}

#if CLIENT
void function FrameworkInformLoadoutResponse(array<string> args)
{
    foreach(string arg in args)
    {
        printt("FrameworkInformLoadoutResponse", arg)
    }
	//TODO: Make this a popup on loadouts screen
    if(args[0] == "#REJECED")
    {
        print("FrameworkInformLoadoutResponse: Loadout rejected by server due to bad format")
    }
    string fileName = args[0]
    frameworkPersistentTitanLoadout loadout = clientframeworkPersistentTitanLoadouts.loadouts[fileName]
    if(args[1] == "#REJECTED")
    {
        loadout.response.status = eLoadoutStatus.REJECED
        if(args[3] != "#FAILEDVALIDATION")
        {
            loadout.response.reason = args[2]
            loadout.response.cause = args[3]
        }
        else
        {
            loadout.response.reason = args[3]
            loadout.response.cause = args[4]
            loadout.response.badValue = args[5]
        }    
    
    }
    else
    {
        loadout.response.status = eLoadoutStatus.ACCEPTED
    }
}

#endif
bool function PlayerHasModdedTitanLoadout()
{
    return clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex != ""
}
string function GetCurrentModdedPersistentTitanLoadoutIndex()
{
    return clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex
}
frameworkPersistentTitanLoadout function GetModdedPersistentTitanLoadout(string index)
{
    return clientframeworkPersistentTitanLoadouts.loadouts[index]
}
frameworkPersistentTitanLoadout function GetCurrentModdedPersistentTitanLoadout()
{
    return clientframeworkPersistentTitanLoadouts.loadouts[clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex]
}
TitanLoadoutDef function GetCurrentModdedTitanLoadoutDef()
{
    return clientframeworkPersistentTitanLoadouts.loadouts[clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex].loadout
}
void function setModdedTitanLoadoutIndex(string index, callback = false)
{
    clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex = index
    #if UI
    if(!callback)
        RunClientScript("setModdedTitanLoadoutIndex", index, true)
    //ClientCommand("titanFrameworkSelectLoadout " + index )
    #endif
    #if CLIENT
    if(!callback)
        RunUIScript( "setModdedTitanLoadoutIndex", index, true ) 
    if(index != "")
        describeNewLoadoutToServer(GetCurrentModdedPersistentTitanLoadout())
    NSSaveJSONFile("frameworkCFG.json", {version = "1.2.1", moddedSelected = index})
    #endif
}
void function cl_titanFrameworkPersistenceInitThread()
{
    if(!NSDoesFileExist("frameworkCFG.json"))
    {
        NSSaveJSONFile("frameworkCFG.json", {version = "1.2.1"});
    }
    NSLoadJSONFile( "frameworkCFG.json", loadPersistentData)
}


void function loadPersistentData(table data)
{
    if(data.moddedSelected != null)
    {
        clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex = expect string(data.moddedSelected)
    }
    else
    {
        clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex = ""
    }
    foreach(string loadout in NSGetAllFiles() )
    {
        if(loadout == "frameworkCFG.json")
        {
            continue
        }
        clientframeworkPersistentTitanLoadouts.filesToLoad.append(loadout)
        NSLoadJSONFile( loadout, LoadPersistentTitanLoadout )
    }

    thread InitialClientsideValidation()
    #if CLIENT
        thread InformFrameworkLoadouts()
    #endif
}

void function CreateNewTitanLoadout(bool callback = false)
{
    frameworkHelperValues.savingNewLoadout = true
    if(!callback)
    {
    #if UI
        RunClientScript("CreateNewTitanLoadout", true)
    #endif
    #if CLIENT
        RunUIScript("CreateNewTitanLoadout", true)//Realistically this will only ever be called by ui, but just in case
    #endif

    }
    if(!callback)
        thread saveNewTitanLoadout(createClientFrameworkLoadoutFromLoadoutDef(GetDefaultTitanLoadout(0)) , callback)
    else
        saveNewTitanLoadout(createClientFrameworkLoadoutFromLoadoutDef(GetDefaultTitanLoadout(0)) , callback)
}
void function saveNewTitanLoadout(frameworkPersistentTitanLoadout loadout, callback = false)
{
    int i = 0
    clientframeworkPersistentTitanLoadouts.loadoutsToSave.append(loadout)
    while(clientframeworkPersistentTitanLoadouts.loadoutsToSave[0] != loadout)
    {
        printt("Waiting for mutex", clientframeworkPersistentTitanLoadouts.loadoutsToSave[0].loadoutName)
        WaitFrame() //when the shitty mutex is sus
    }
    array<string> loadouts
    if(!callback)
        loadouts = NSGetAllFiles()
    else
    {
        foreach(string existingClientLoadoutName, frameworkPersistentTitanLoadout existingClientLoadout in clientframeworkPersistentTitanLoadouts.loadouts)
        {
            loadouts.append(existingClientLoadoutName)
        }
        
    }
    loadouts.removebyvalue("frameworkCFG.json")
    loadouts.sort(SortFrameworkTitanLoadoutsByName)
    foreach(string existingLoadout in loadouts){
        print(existingLoadout)
        if(existingLoadout == "LOADOUT_" + i + ".json")
            i++
        else
            break
    }
    table loadoutTable
    loadoutTable.loadoutName <- loadout.loadoutName
    loadoutTable.titanName <- loadout.titanName
    loadoutTable.sourceMod <- loadout.sourceMod
    loadoutTable.sourceModVersion <- loadout.sourceModVersion
    loadoutTable.loadout <- TitanLoadoutDefToTable(loadout.loadout)
    loadoutTable.additionalVars <- loadout.additionalVars
    loadoutTable.fileName <- ("LOADOUT_" + i + ".json")
    if(!callback)
    {
        NSSaveJSONFile(loadoutTable.fileName, loadoutTable) // callback implies we have already run this, dont save twice
    }
    loadout.fileName = ("LOADOUT_" + i + ".json")
    clientframeworkPersistentTitanLoadouts.loadouts["LOADOUT_" + i + ".json"] <- loadout
    clientframeworkPersistentTitanLoadouts.loadoutsToSave.remove(0)
    frameworkHelperValues.savingNewLoadout = false
    //setModdedTitanLoadoutIndex("LOADOUT_" + i + ".json", true)
}
void function saveTitanLoadout(frameworkPersistentTitanLoadout loadout)
{
    table loadoutTable
    loadoutTable.loadoutName <- loadout.loadoutName
    loadoutTable.titanName <- loadout.titanName
    loadoutTable.sourceMod <- loadout.sourceMod
    loadoutTable.sourceModVersion <- loadout.sourceModVersion
    loadoutTable.loadout <- TitanLoadoutDefToTable(loadout.loadout)
    loadoutTable.additionalVars <- loadout.additionalVars
    loadoutTable.fileName <- loadout.fileName
    NSSaveJSONFile(loadout.fileName, loadoutTable)
    clientframeworkPersistentTitanLoadouts.loadouts[loadout.fileName] <- loadout
}
void function DeleteFrameworkTitanLoadout(string fileName, bool callback = false)
{
    delete clientframeworkPersistentTitanLoadouts.loadouts[fileName]
    
    if(!callback)
    {
        #if UI
            RunClientScript("DeleteFrameworkTitanLoadout", fileName, true)
        #endif
        #if CLIENT
            RunUIScript("DeleteFrameworkTitanLoadout", fileName, true)//Realistically this will only ever be called by ui, but just in case
        #endif
        NSDeleteFile(fileName)
    }

    
}
void function setFrameworkTitanLoadoutValue( string fileName, string property, string value, bool callback = false)
{
    frameworkPersistentTitanLoadout loadout = clientframeworkPersistentTitanLoadouts.loadouts[fileName]
    table<string, bool functionref(string value, string property, TitanLoadoutDef acceptedLoadout)> validation
    if(GetModdedTitanClasses().contains(loadout.titanName))
    {
        validation = GetModdedTitanData(loadout.titanName).derivedData.PersistentValuesValidation
    }
    else if(IsBaseTitan(loadout.titanName))
    {
        validation = getBaseLoadoutValidationTable()
    }
    if(property in validation)
    {
        if(validation[property](value, property, loadout.loadout))
        {
            printt("setting" + " " + property + " " + value + " for " + loadout.loadoutName + " from " + loadout.sourceMod + " " + loadout.sourceModVersion + " in " + fileName + " with callback " + ( callback ? "true" : "false" ) )
            if(!TrySetTitanLoadoutValue(loadout.loadout, property, value))
            {
                loadout.additionalVars[property] <- value
            }
            UpdateDerivedFrameworkLoadoutValues(loadout)
            if(!callback)
            {
                #if UI
                RunClientScript( "setFrameworkTitanLoadoutValue", fileName, property, value, true)
                #endif
                #if CLIENT
                RunUIScript( "setFrameworkTitanLoadoutValue", fileName, property, value, true)
                #endif
            }
            else
            {
                saveTitanLoadout(loadout)
                #if UI
                ClientCommand("SetFrameworkTitanLoadoutValue" + " " + fileName + " " + property + " " + value)
                #endif
                #if CLIENT
                GetLocalClientPlayer().ClientCommand("SetFrameworkTitanLoadoutValue" + " " + fileName + " " + property + " " + value)
                #endif
            }
        }
        else
        {
            printt("failed validation", property, value)
        }
    }
    else
    {
        printt("Invalid property", property)
    }
}
void function SetFrameworkTitanloadoutName( string fileName, string newName, bool callback = false)
{
    if(!callback)
    {
        #if UI
        RunClientScript( "SetFrameworkTitanloadoutName", fileName, newName, true)
        #endif
        #if CLIENT
        RunUIScript( "SetFrameworkTitanloadoutName", fileName, newName, true)
        #endif
    }

    print("Renaming " + fileName + " to " + newName + " with callback " + ( callback ? "true" : "false" ) )

    frameworkPersistentTitanLoadout loadout = clientframeworkPersistentTitanLoadouts.loadouts[fileName]
    loadout.loadoutName = newName
    saveTitanLoadout(loadout)
}

void function setFrameworkTitanLoadoutValueCallback(entity player, string fileName, string property, string value, bool callback = false)
{
    setFrameworkTitanLoadoutValue(fileName, property, value, true)
}
void function LoadPersistentTitanLoadout(table Table)
{
    frameworkPersistentTitanLoadout loadout
    loadout.loadoutName = expect string(Table["loadoutName"])
    loadout.titanName = expect string(Table["titanName"])
    loadout.sourceMod = expect string(Table["sourceMod"])
    loadout.sourceModVersion = expect string(Table["sourceModVersion"])
    loadout.fileName = expect string(Table["fileName"])
    TableToTitanLoadoutInplace(loadout.loadout, expect table( Table["loadout"] ) )
    loadout.additionalVars = expect table( Table["additionalVars"] )
    loadout.loadout.frameworkLoadoutRef = loadout.fileName
    clientframeworkPersistentTitanLoadouts.loadouts[loadout.fileName] <- loadout
    UpdateDerivedFrameworkLoadoutValues(loadout)
    clientframeworkPersistentTitanLoadouts.filesToLoad.removebyvalue(expect string(Table["fileName"]))
}
void function UpdateDerivedFrameworkLoadoutValues( frameworkPersistentTitanLoadout loadout )
{
    bool canHavePrime 
    if(IsBaseTitan(loadout.titanName) && loadout.titanName != "vanguard")
        canHavePrime = true
    else if(GetModdedTitanClasses().contains(loadout.titanName))
        canHavePrime = GetModdedTitanData(loadout.titanName).altChassisType == frameworkAltChassisMethod.PRIME_TITAN
    if(canHavePrime)
    {
        if(loadout.loadout.isPrime == "titan_is_prime" && loadout.loadout.setFile.find("prime") == null)//This is really scuffed, oh well!
        {
            print("titan is prime, updating set file")
            loadout.loadout.setFile = GetPrimeTitanSetFileFromNonPrimeSetFile(loadout.loadout.setFile)
        }
        else if (loadout.loadout.isPrime == "titan_is_not_prime" && loadout.loadout.setFile.find("prime") != null)//This is really scuffed, oh well!
            loadout.loadout.setFile = GetBaseTitanSetFileFromPrimeSetFile(loadout.loadout.setFile)
    }
    loadout.loadout.setFileMods = GetSetFileModsForSettingType("titan", [ loadout.loadout.passive1, loadout.loadout.passive2, loadout.loadout.passive3, loadout.loadout.passive4, loadout.loadout.passive5, loadout.loadout.passive6 ] )


    //TODO: Add callbacks for custom derived values
}
void function SetTitanLoadoutFromClass( string titanClass, string fileName, callback = false )
{
    if(fileName == "")
	{
		print("Trying to use titan class select without a modded titan loadout selected")
	}
    print("Setting titan loadout from class " + titanClass + " " + fileName)
	frameworkPersistentTitanLoadout loadout
	if(GetModdedTitanClasses().contains(titanClass))
    {
		loadout = createClientFrameworkLoadoutFromLoadoutDef( GetModdedTitanByClassNoPersist(titanClass))
        foreach(string persistentValue, int itemType in GetModdedTitanLoadoutPassiveTypes(titanClass))
        {
            if(!TrySetTitanLoadoutValue(loadout.loadout, persistentValue, GetAllItemsOfType( itemType )[0].ref))
            {
                loadout.additionalVars[persistentValue] <- GetAllItemsOfType( itemType )[0].ref
            }
        }
        foreach(string persistentValue, CustomPersistentVar value in GetModdedTitanData(titanClass).ValidationOverrides)
        {
            if(!TrySetTitanLoadoutValue(loadout.loadout, persistentValue, value.defaultValue))
            {
                loadout.additionalVars[persistentValue] <- value.defaultValue
            }
        }
        
    }    //Major todo, make this actually use titandata instead of default style loadout def, so extra values are supported
	else if (IsBaseTitan(titanClass))
		loadout = createClientFrameworkLoadoutFromLoadoutDef( GetBaseTitanByClassNoPersist(titanClass))
	else
	{
		print("Trying to use titan class select with an invalid titan class")
		return
	}
	loadout.fileName = fileName
	saveTitanLoadout( loadout )
    #if CLIENT
    if(shouldPrintDevStuff())
        print("Updating titan model")
    UpdateTitanModel( GetLocalClientPlayer(),  GetModdedTitanLoadoutNameIndex( fileName ) + 10 )
    #endif
    UpdateDerivedFrameworkLoadoutValues(loadout)
    if(!callback)
    {
        #if UI
        RunClientScript( "SetTitanLoadoutFromClass", titanClass, fileName, true)
        #endif
        #if CLIENT
        RunUIScript( "SetTitanLoadoutFromClass", titanClass, fileName, true)
        #endif
    }

    #if CLIENT
    GetLocalClientPlayer().ClientCommand("setFrameworkTitanLoadoutFromClass " + fileName + " " + titanClass)
    #endif
}



void function InformFrameworkLoadouts()
{//Clientcommand limit is around 33 per second, but lets leave it at 15 to be safe
    //WaitSignal( level, "CachedLoadoutsReady" ) unneeded i think
    float timeSearching = Time()
    while(clientframeworkPersistentTitanLoadouts.filesToLoad.len() > 0)
    {
        printt("Waiting for loadouts to load")
        wait 0.1
        if(Time() - timeSearching > 2)
        {
            foreach(string fileName in clientframeworkPersistentTitanLoadouts.filesToLoad)
            {
                if(fileName in clientframeworkPersistentTitanLoadouts.loadouts)
                {
                    print("Loadout " + fileName + " already loaded!")
                    clientframeworkPersistentTitanLoadouts.filesToLoad.removebyvalue(fileName)
                    continue
                }
                printt("Loadout " + fileName + " failed to load!, Retrying")
                NSLoadJSONFile( fileName, LoadPersistentTitanLoadout )
                timeSearching = Time()
            }
        }
    }

    if(clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex != "")
    {
        print("Informing server of new loadout")
        describeNewLoadoutToServer(clientframeworkPersistentTitanLoadouts.loadouts[clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex])
    }
    int i = 0
    //foreach(frameworkPersistentTitanLoadout loadout in clientframeworkPersistentTitanLoadouts.loadouts)
    //{
    //    if(loadout.fileName == clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex)
    //    {
    //        continue
    //    }
    //    if(i > 15)
    //    {
    //        wait 1
    //        i = 0
    //        printt("Too many loadouts to inform server of")
    //    }
    //    describeNewLoadoutToServer(loadout)
    //    i++
    //} //Literally just do the used loadout, send the rest only if used or if the server requests it
    //Do ui validation client side
}
void function InitialClientsideValidation()
{
    #if CLIENT
    WaitSignal( level, "CachedLoadoutsReady" )
    #endif
    #if UI
    float timeSearching = Time()
    while(clientframeworkPersistentTitanLoadouts.filesToLoad.len() > 0 )
    {
        printt("Client validation waiting for loadouts to load")
        wait 0.1
        if(Time() - timeSearching > 2)
        {
            foreach(string fileName in clientframeworkPersistentTitanLoadouts.filesToLoad)
            {
                if(fileName in clientframeworkPersistentTitanLoadouts.loadouts)
                {
                    print("Loadout " + fileName + " already loaded!")
                    clientframeworkPersistentTitanLoadouts.filesToLoad.removebyvalue(fileName)
                    continue
                }
                printt("Loadout " + fileName + " failed to load!, Retrying")
                NSLoadJSONFile( fileName, LoadPersistentTitanLoadout )
                timeSearching = Time()
            }
        }
    }
    while( !uiGlobal.loadoutsInitialized)
    {
        WaitFrame()
    }
    #endif
    foreach(frameworkPersistentTitanLoadout loadout in clientframeworkPersistentTitanLoadouts.loadouts)
    {
        bool titanDoesExist = GetModdedTitanClasses().contains(loadout.titanName) || IsBaseTitan(loadout.titanName)
        if(!titanDoesExist && (loadout.response.status == eLoadoutStatus.NO_RESPONSE))
        {       
            loadout.response.status = eLoadoutStatus.REJECTED
            loadout.response.reason = "#CLIENT_LOADOUT_REJECTED_TITAN_DOES_NOT_EXIST"
            loadout.response.cause = loadout.loadoutName
            loadout.response.badValue = loadout.titanName
        }
    }//Initial simple validation function

}
void function describeNewLoadoutToServer(frameworkPersistentTitanLoadout loadout)
{
    bool multicommand
    string resultString = ""
    resultString += "titanName" + " " + loadout.titanName  + " " 
    resultString += "fileName" + " " + loadout.fileName + " "
    if(clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex == loadout.fileName)
    {
        resultString += "select" + " " + "yes "
    }
    else
    {
        resultString += "select" + " " + "no "
    }
    table<string, bool functionref(string value, string property, TitanLoadoutDef acceptedLoadout)> PersistentVars
    if(GetModdedTitanClasses().contains(loadout.titanName))
    {
        print("Modded titan")
        PersistentVars = GetModdedTitanData(loadout.titanName).derivedData.PersistentValuesValidation
    }
    else if(IsBaseTitan(loadout.titanName))
    {
        print("Base titan")
        PersistentVars = getBaseLoadoutValidationTable()
    } 
    table loadoutTable = TitanLoadoutDefToTable(loadout.loadout)
    foreach(string varName, bool functionref(string value, string property, TitanLoadoutDef acceptedLoadout) valid in PersistentVars)
    {
        if(varName in loadout.additionalVars)
            resultString += varName + " " + loadout.additionalVars[varName] + " "
        else if (varName in loadoutTable)
            resultString += varName + " " + loadoutTable[varName] + " "
        if(resultString.len() >= 450) //500 ish is the max length of a clientcommand 
        {
            resultString += "multicommand yes"
            multicommand = true
            GetLocalClientPlayer().ClientCommand("titanFrameworkNewLoadout " + resultString)
            resultString = "titanName " + loadout.titanName + " fileName " + loadout.fileName + " select " + ( clientframeworkPersistentTitanLoadouts.moddedLoadoutIndex == loadout.fileName ? "yes " : "no " )
        }
    }
    printt("resultString", resultString)
    if(shouldPrintDevStuff())
    {    
        PrintTable(loadoutTable)
        PrintTable(loadout.additionalVars)
    }
    print(resultString.len())
    GetLocalClientPlayer().ClientCommand("titanFrameworkNewLoadout " + resultString) 
}//script_client thread describeNewLoadoutToServer(clientframeworkPersistentTitanLoadouts.loadouts["LOADOUT_0.json"])